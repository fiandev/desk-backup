#!/bin/sh

# ==============================================================================
# DESK-TOOL: A Git-based Desktop Configuration Backup & Recovery Script
# ==============================================================================

# --- CONFIGURATION (REQUIRED) ---
# The script will look for a file at this path to get the repository URL.
CONFIG_REPO="$HOME/.deskbackup-config"

# --- INTERNAL LOCATIONS ---
# Location to store the bare git repository.
DOTFILES_DIR="$HOME/.dotfiles"

# Location to store non-git backup files (like package lists).
BACKUP_DIR="$HOME/.local/share/desk-backup"

# Create the backup directory if it doesn't exist.
mkdir -p "$BACKUP_DIR"

# --- INTERNAL GIT ALIAS ---
dotfiles() {
    /usr/bin/git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

# ==============================================================================
# PACKAGE MANAGER FUNCTIONS
# ==============================================================================

# --- FUNCTION: fn_backup_packages ---
# Detects the package manager and saves a list of installed packages.
fn_backup_packages() {
    echo "üì¶ Backing up package lists..."

    # DNF (Fedora, CentOS)
    if command -v dnf >/dev/null 2>&1; then
        echo "   -> Found dnf. Saving package list."
        dnf repoquery --userinstalled --qf '%{name}' > "$BACKUP_DIR/packages-dnf.txt"
    # APT (Debian, Ubuntu)
    elif command -v apt >/dev/null 2>&1; then
        echo "   -> Found apt. Saving package list."
        apt-mark showmanual > "$BACKUP_DIR/packages-apt.txt"
    # Pacman (Arch Linux)
    elif command -v pacman >/dev/null 2>&1; then
        echo "   -> Found pacman. Saving package list."
        pacman -Qqe > "$BACKUP_DIR/packages-pacman.txt"
    else
        echo "   -> No supported package manager (dnf, apt, pacman) found. Skipping."
    fi

    # Flatpak (Universal)
    if command -v flatpak >/dev/null 2>&1; then
        echo "   -> Found flatpak. Saving application list."
        flatpak list --app --columns=application > "$BACKUP_DIR/packages-flatpak.txt"
    fi
}

# --- FUNCTION: fn_restore_packages ---
# Restores packages from the backup lists if the corresponding manager is available.
fn_restore_packages() {
    echo "üì¶ Restoring applications from backup lists..."

    # DNF
    if [ -f "$BACKUP_DIR/packages-dnf.txt" ] && command -v dnf >/dev/null 2>&1; then
        echo "   -> Found dnf list and dnf command. Installing packages..."
        xargs sudo dnf install -y < "$BACKUP_DIR/packages-dnf.txt"
    fi

    # APT
    if [ -f "$BACKUP_DIR/packages-apt.txt" ] && command -v apt >/dev/null 2>&1; then
        echo "   -> Found apt list and apt command. Installing packages..."
        xargs sudo apt install -y < "$BACKUP_DIR/packages-apt.txt"
    fi

    # Pacman
    if [ -f "$BACKUP_DIR/packages-pacman.txt" ] && command -v pacman >/dev/null 2>&1; then
        echo "   -> Found pacman list and pacman command. Installing packages..."
        xargs sudo pacman -S --noconfirm --needed < "$BACKUP_DIR/packages-pacman.txt"
    fi

    # Flatpak
    if [ -f "$BACKUP_DIR/packages-flatpak.txt" ] && command -v flatpak >/dev/null 2>&1; then
        echo "   -> Found flatpak list. Installing applications..."
        xargs -r flatpak install -y < "$BACKUP_DIR/packages-flatpak.txt"
    fi
}

# ==============================================================================
# MAIN FUNCTIONS
# ==============================================================================

# --- FUNCTION: desk-import ---
fn_import() {
    REPO_URL=$(cat "$CONFIG_REPO")
    
    echo "--- Starting Full System Import ---"

    if [ -d "$DOTFILES_DIR" ]; then
        echo "‚ö†Ô∏è WARNING: A '.dotfiles' directory already exists. Removing it to start fresh."
        rm -rf "$DOTFILES_DIR"
    fi

    if [ -z "$REPO_URL" ]; then
        while [ -z "$REPO_URL" ]; do
            echo "Please enter the SSH or HTTPS URL for your dotfiles repository: "
            read -r REPO_URL
            if [ -z "$REPO_URL" ]; then
                echo "‚ùå Repository URL cannot be empty. Please try again."
            fi
        done
    fi

    echo "üöö Cloning dotfiles from '$REPO_URL'..."
    git clone --bare "$REPO_URL" "$DOTFILES_DIR"
    if [ $? -ne 0 ]; then
        echo "‚ùå ERROR: Failed to clone repository. Please check the URL and your permissions (SSH keys)."
        exit 1
    fi

    echo "‚öôÔ∏è Checking out configuration files to home directory..."
    dotfiles checkout -f
    
    if [ $? = 0 ]; then
        echo "‚úÖ Checkout successful."
    else
        echo "‚ö†Ô∏è WARNING: Checkout failed. There might be conflicting files."
    fi
    
    dotfiles config --local status.showUntrackedFiles no
    echo "üëç Basic setup complete. Starting recovery of apps and settings..."
    
    fn_recovery
}

# --- FUNCTION: desk-recovery ---
fn_recovery() {
    echo "üîÑ Restoring tracked files from Git..."
    dotfiles checkout -f
    fn_restore_packages
    echo "‚úÖ Recovery process complete."
}

# --- FUNCTION: desk-backup ---
fn_backup() {
    if [ $# -eq 0 ]; then
        echo "Usage: desk-backup <path/file1> <path/folder2> ..."
        exit 1
    fi
    
    echo "üìã Adding new entries to Git tracking: $@"
    dotfiles add "$@"
    
    echo "üìù Creating commit..."
    dotfiles commit -m "feat: track $(basename "$1")"
    
    echo "üöÄ Pushing changes to remote repository..."
    dotfiles push

    fn_backup_packages
    dotfiles add "$BACKUP_DIR"
    dotfiles commit -m "chore: update package lists"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master

    echo "‚úÖ Backup successful."
}

# --- FUNCTION: desk-ignore ---
fn_ignore() {
    if [ $# -eq 0 ]; then
        echo "Usage: desk-ignore <path/file>"
        exit 1
    fi

    echo "üôà Stop tracking file (without deleting from disk): $@"
    dotfiles rm --cached -r "$@"
    dotfiles commit -m "refactor: ignore $(basename "$1")"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master
        
    echo "‚úÖ File is no longer tracked by Git."
}

# --- FUNCTION: desk-remove ---
fn_remove() {
    if [ $# -eq 0 ]; then
        echo "Usage: desk-remove <path/file>"
        exit 1
    fi
    
    echo "üóëÔ∏è Removing file from disk and Git tracking: $@"
    dotfiles rm -r "$@"
    dotfiles commit -m "feat: remove $(basename "$1")"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master

    echo "‚úÖ File has been deleted."
}

# --- FUNCTION: fn_purge_history ---
fn_purge_history() {
    echo "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è"
    echo "You are about to remove a file from the ENTIRE Git history."
    read -r confirmation
    if [ "$confirmation" != "yes" ]; then
        echo "Operation cancelled."
        exit 1
    fi

    echo "üî• Purging '$2' from the entire history..."
    dotfiles filter-repo --path "$2" --invert-paths --force
    
    echo "üöÄ Force pushing to rewrite history on the remote repository..."
    dotfiles push --force
    echo "‚úÖ History has been rewritten."
}


# ==============================================================================
# MAIN ROUTER (SUBCOMMAND HANDLING)
# ==============================================================================

COMMAND=$1
shift

case $COMMAND in
    import)
        fn_import
        ;;
    recovery)
        fn_recovery
        ;;
    backup)
        fn_backup "$@"
        ;;
    log)
        dotfiles log
        ;;
    ignore)
        fn_ignore "$@"
        ;;
    remove)
        if [ "$1" = "--purge-history" ]; then
            shift
            fn_purge_history "$@"
        else
            fn_remove "$@"
        fi
        ;;
    *)
        echo "Invalid command: $COMMAND"
        echo "Usage: desk.sh [import|recovery|backup|ignore|remove|log]"
        exit 1
        ;;
esac