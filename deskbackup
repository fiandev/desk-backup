#!/bin/sh

# ==============================================================================
# DESK-TOOL: A Git-based Desktop Configuration Backup & Recovery Script
# ==============================================================================

# --- COLOR DEFINITIONS ---
GREEN=$(printf '\033[0;32m')
YELLOW=$(printf '\033[1;33m')
RED=$(printf '\033[0;31m')
BLUE=$(printf '\033[0;34m')
NC=$(printf '\033[0m') # No Color

# --- CONFIGURATION (REQUIRED) ---
CONFIG_REPO="$HOME/.deskbackup-config"

# --- INTERNAL LOCATIONS ---
DOTFILES_DIR="$HOME/.dotfiles"
BACKUP_DIR="$HOME/.local/share/desk-backup"

mkdir -p "$BACKUP_DIR"

# --- INTERNAL GIT ALIAS ---
dotfiles() {
    /usr/bin/git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

# ==============================================================================
# BANNER
# ==============================================================================

fn_show_banner() {
    printf "$BLUE"
    echo "
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù 
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     
                                                                                     
 A collection of shell scripts to automatically back up, restore, and sync a Linux desktop configuration.

 Created by fiandev
"
    printf "$NC"
}

# ==============================================================================
# PACKAGE MANAGER FUNCTIONS
# ==============================================================================

fn_backup_packages() {
    printf "$BLUE%s$NC\n" "üì¶ Backing up package lists..."

    if command -v dnf >/dev/null 2>&1; then
        printf "   -> Found dnf. Saving package list.\n"
        dnf repoquery --userinstalled --qf '%{name}' > "$BACKUP_DIR/packages-dnf.txt"
    elif command -v apt >/dev/null 2>&1; then
        printf "   -> Found apt. Saving package list.\n"
        apt-mark showmanual > "$BACKUP_DIR/packages-apt.txt"
    elif command -v pacman >/dev/null 2>&1; then
        printf "   -> Found pacman. Saving package list.\n"
        pacman -Qqe > "$BACKUP_DIR/packages-pacman.txt"
    else
        printf "$YELLOW%s$NC\n" "   -> No supported package manager found. Skipping native packages."
    fi

    if command -v flatpak >/dev/null 2>&1; then
        printf "   -> Found flatpak. Saving application list.\n"
        flatpak list --app --columns=application > "$BACKUP_DIR/packages-flatpak.txt"
    fi
}

fn_restore_packages() {
    printf "$BLUE%s$NC\n" "üì¶ Restoring applications from backup lists..."

    if [ -f "$BACKUP_DIR/packages-dnf.txt" ] && command -v dnf >/dev/null 2>&1; then
        printf "   -> Found dnf list. Installing packages...\n"
        xargs sudo dnf install -y < "$BACKUP_DIR/packages-dnf.txt"
    fi
    if [ -f "$BACKUP_DIR/packages-apt.txt" ] && command -v apt >/dev/null 2>&1; then
        printf "   -> Found apt list. Installing packages...\n"
        xargs sudo apt install -y < "$BACKUP_DIR/packages-apt.txt"
    fi
    if [ -f "$BACKUP_DIR/packages-pacman.txt" ] && command -v pacman >/dev/null 2>&1; then
        printf "   -> Found pacman list. Installing packages...\n"
        xargs sudo pacman -S --noconfirm --needed < "$BACKUP_DIR/packages-pacman.txt"
    fi
    if [ -f "$BACKUP_DIR/packages-flatpak.txt" ] && command -v flatpak >/dev/null 2>&1; then
        printf "   -> Found flatpak list. Installing applications...\n"
        xargs -r flatpak install -y < "$BACKUP_DIR/packages-flatpak.txt"
    fi
}

# ==============================================================================
# MAIN FUNCTIONS
# ==============================================================================

fn_import() {
    fn_show_banner
    REPO_URL=$(cat "$CONFIG_REPO")
    
    printf "$BLUE%s$NC\n" "--- Starting Full System Import ---"

    if [ -d "$DOTFILES_DIR" ]; then
        printf "$YELLOW%s$NC\n" "‚ö†Ô∏è WARNING: A '.dotfiles' directory already exists. Removing it to start fresh."
        rm -rf "$DOTFILES_DIR"
    fi

    if [ -z "$REPO_URL" ]; then
        while [ -z "$REPO_URL" ]; do
            printf "$YELLOW%s$NC" "Please enter the SSH or HTTPS URL for your dotfiles repository: "
            read -r REPO_URL
            if [ -z "$REPO_URL" ]; then
                printf "$RED%s$NC\n" "‚ùå Repository URL cannot be empty. Please try again."
            fi
        done
    fi

    printf "$BLUE%s$NC\n" "üöö Cloning dotfiles from '$REPO_URL' ‡ÆÆ‡ØÇ‡Æ©‡Øç‡Æ±‡Ææ‡ÆÆ‡Øç ‡Æ§‡Æ∞‡Æ™‡Øç‡Æ™‡ØÅ...".
    git clone --bare "$REPO_URL" "$DOTFILES_DIR"
    if [ $? -ne 0 ]; then
        printf "$RED%s$NC\n" "‚ùå ERROR: Failed to clone repository. Please check the URL and your permissions (SSH keys)."
        exit 1
    fi

    printf "$BLUE%s$NC\n" "‚öôÔ∏è Checking out configuration files to home directory..."
    dotfiles checkout -f
    
    if [ $? = 0 ]; then
        printf "$GREEN%s$NC\n" "‚úÖ Checkout successful."
    else
        printf "$YELLOW%s$NC\n" "‚ö†Ô∏è WARNING: Checkout failed. There might be conflicting files."
    fi
    
    dotfiles config --local status.showUntrackedFiles no
    printf "$GREEN%s$NC\n" "üëç Basic setup complete. Starting recovery of apps and settings..."
    
    fn_recovery
}

fn_recovery() {
    printf "$BLUE%s$NC\n" "üîÑ Restoring tracked files from Git..."
    dotfiles checkout -f
    fn_restore_packages
    printf "$GREEN%s$NC\n" "‚úÖ Recovery process complete."
}

fn_backup() {
    if [ $# -eq 0 ]; then
        printf "$RED%s$NC\n" "Usage: desk-backup <path/file1> <path/folder2> ..."
        exit 1
    fi
    
    printf "$BLUE%s$NC\n" "üìã Adding new entries to Git tracking: $@"
    dotfiles add "$@"
    
    printf "$BLUE%s$NC\n" "üìù Creating commit..."
    dotfiles commit -m "feat: track $(basename "$1")"
    
    printf "$BLUE%s$NC\n" "üöÄ Pushing changes to remote repository..."
    dotfiles push

    fn_backup_packages
    dotfiles add "$BACKUP_DIR"
    dotfiles commit -m "chore: update package lists"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master

    printf "$GREEN%s$NC\n" "‚úÖ Backup successful."
}

fn_ignore() {
    if [ $# -eq 0 ]; then
        printf "$RED%s$NC\n" "Usage: desk-ignore <path/file>"
        exit 1
    fi

    printf "$YELLOW%s$NC\n" "üôà Stop tracking file (without deleting from disk): $@"
    dotfiles rm --cached -r "$@"
    dotfiles commit -m "refactor: ignore $(basename "$1")"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master
        
    printf "$GREEN%s$NC\n" "‚úÖ File is no longer tracked by Git."
}

fn_remove() {
    if [ $# -eq 0 ]; then
        printf "$RED%s$NC\n" "Usage: desk-remove <path/file>"
        exit 1
    fi
    
    printf "$YELLOW%s$NC\n" "üóëÔ∏è Removing file from disk and Git tracking: $@"
    dotfiles rm -r "$@"
    dotfiles commit -m "feat: remove $(basename "$1")"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master

    printf "$GREEN%s$NC\n" "‚úÖ File has been deleted."
}

fn_purge_history() {
    printf "$RED%s$NC\n" "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è"
    printf "$YELLOW%s$NC\n" "You are about to remove a file from the ENTIRE Git history."
    printf "$YELLOW%s$NC" "Are you absolutely sure? (type 'yes' to continue): "
    read -r confirmation
    if [ "$confirmation" != "yes" ]; then
        printf "$GREEN%s$NC\n" "Operation cancelled."
        exit 1
    fi

    printf "$RED%s$NC\n" "üî• Purging '$2' from the entire history..."
    dotfiles filter-repo --path "$2" --invert-paths --force
    
    printf "$RED%s$NC\n" "üöÄ Force pushing to rewrite history on the remote repository..."
    dotfiles push --force
    printf "$GREEN%s$NC\n" "‚úÖ History has been rewritten."
}


# ==============================================================================
# MAIN ROUTER (SUBCOMMAND HANDLING)
# ==============================================================================

COMMAND=$1
shift

case $COMMAND in
    import)
        fn_import
        ;;
    recovery)
        fn_recovery
        ;;
    backup)
        fn_backup "$@"
        ;;
    log)
        dotfiles log
        ;;
    ignore)
        fn_ignore "$@"
        ;;
    remove)
        if [ "$1" = "--purge-history" ]; then
            shift
            fn_purge_history "$@"
        else
            fn_remove "$@"
        fi
        ;;
    *)
        fn_show_banner
        ;;
esac
