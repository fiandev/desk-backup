#!/bin/sh

# ==============================================================================
# DESK-TOOL: A Git-based Desktop Configuration Backup & Recovery Script
# ==============================================================================

# --- CONFIGURATION (REQUIRED) ---
# The script will look for a file at this path to get the repository URL.
CONFIG_REPO="$HOME/.deskbackup-config"

# --- INTERNAL LOCATIONS ---
# Location to store the bare git repository.
DOTFILES_DIR="$HOME/.dotfiles"

# Location to store non-git backup files (like package lists).
BACKUP_DIR="$HOME/.local/share/desk-backup"

# Create the backup directory if it doesn't exist.
mkdir -p "$BACKUP_DIR"

# --- INTERNAL GIT ALIAS ---
# This function is the core of the script. It allows running Git commands
# on the bare repository located in $DOTFILES_DIR while using $HOME as the
# working directory. This is what makes it possible to track any file
# in the home directory without initializing a git repo there.
dotfiles() {
    /usr/bin/git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

# ==============================================================================
# MAIN FUNCTIONS
# ==============================================================================

# --- FUNCTION: desk-import ---
# To be run on a new machine. Clones the repo and restores everything.
fn_import() {
    REPO_URL=$(cat "$CONFIG_REPO")
    
    echo "--- Starting Full System Import ---"

    if [ -d "$DOTFILES_DIR" ]; then
        echo "‚ö†Ô∏è WARNING: A '.dotfiles' directory already exists. Removing it to start fresh."
        rm -rf "$DOTFILES_DIR"
    fi

    # If the repository URL is not found in the config file, ask for it interactively.
    if [ -z "$REPO_URL" ]; then
        while [ -z "$REPO_URL" ]; do
            echo "Please enter the SSH or HTTPS URL for your dotfiles repository: "
            read -r REPO_URL
            if [ -z "$REPO_URL" ]; then
                echo "‚ùå Repository URL cannot be empty. Please try again."
            fi
        done
    fi

    echo "üöö Cloning dotfiles from '$REPO_URL'..."
    # Clone the bare repository from the provided URL.
    git clone --bare "$REPO_URL" "$DOTFILES_DIR"
    if [ $? -ne 0 ]; then
        echo "‚ùå ERROR: Failed to clone repository. Please check the URL and your permissions (SSH keys)."
        exit 1
    fi

    echo "‚öôÔ∏è Checking out configuration files to home directory..."
    dotfiles checkout -f
    
    if [ $? = 0 ]; then
        echo "‚úÖ Checkout successful."
    else
        echo "‚ö†Ô∏è WARNING: Checkout failed. There might be conflicting files. Trying to overwrite..."
        # The -f flag should handle this, but as a fallback, this is a good place
        # for a more robust error handling in the future.
    fi
    
    # Configure the local repository to not show untracked files.
    # This is crucial to avoid `git status` showing every file in the home directory.
    dotfiles config --local status.showUntrackedFiles no
    echo "üëç Basic setup complete. Starting recovery of apps and settings..."
    
    # Call the recovery function to install applications.
    fn_recovery
}

# --- FUNCTION: desk-recovery ---
# Restores files from git and reinstalls applications from the list.
fn_recovery() {
    echo "üîÑ Restoring tracked files from Git..."
    dotfiles checkout -f

    echo "üì¶ Restoring applications from the backup list..."
    if [ -f "$BACKUP_DIR/packages-dnf.txt" ]; then
        echo "Fedora (DNF): Installing packages..."
        # We use xargs to handle a potentially long list of packages.
        xargs sudo dnf install -y < "$BACKUP_DIR/packages-dnf.txt"
    else
        echo "DNF package list file not found."
    fi
    
    if [ -f "$BACKUP_DIR/packages-flatpak.txt" ]; then
        echo "Flatpak: Installing applications..."
        xargs -r flatpak install -y < "$BACKUP_DIR/packages-flatpak.txt"
    else
        echo "Flatpak application list file not found."
    fi

    echo "‚úÖ Recovery process complete."
}

# --- FUNCTION: desk-backup ---
# Adds files/folders to Git, commits, and pushes.
fn_backup() {
    if [ $# -eq 0 ]; then
        echo "Usage: desk-backup <path/file1> <path/folder2> ..."
        exit 1
    fi
    
    echo "üìã Adding new entries to Git tracking: $@"
    dotfiles add "$@"
    
    echo "üìù Creating commit..."
    # The commit message includes the name of the last file/folder added.
    dotfiles commit -m "feat: track $(basename "$1")"
    
    echo "üöÄ Pushing changes to remote repository..."
    dotfiles push

    # Always back up the package list every time a file is backed up.
    echo "üì¶ Backing up the latest application list..."
    dnf repoquery --userinstalled --qf '%{name}' > "$BACKUP_DIR/packages-dnf.txt"
    flatpak list --app --columns=application > "$BACKUP_DIR/packages-flatpak.txt"
    dotfiles add "$BACKUP_DIR"
    dotfiles commit -m "chore: update package lists"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master

    echo "‚úÖ Backup successful."
}

# --- FUNCTION: desk-ignore ---
# Stops tracking a file, but the file remains on the disk.
fn_ignore() {
    if [ $# -eq 0 ]; then
        echo "Usage: desk-ignore <path/file>"
        exit 1
    fi

    echo "üôà Stop tracking file (without deleting from disk): $@"
    dotfiles rm --cached -r "$@"
    dotfiles commit -m "refactor: ignore $(basename "$1")"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master
        
    echo "‚úÖ File is no longer tracked by Git."
}

# --- FUNCTION: desk-remove ---
# Deletes a file from the disk & history (safe & advanced versions).
fn_remove() {
    if [ $# -eq 0 ]; then
        echo "Usage: desk-remove <path/file>"
        exit 1
    fi
    
    echo "üóëÔ∏è Removing file from disk and Git tracking: $@"
    dotfiles rm -r "$@"
    dotfiles commit -m "feat: remove $(basename "$1")"
    dotfiles pull origin master --rebase
    dotfiles push --set-upstream origin master

    echo "‚úÖ File has been deleted. Its history prior to deletion still exists in Git."
    echo "   To completely purge from history (advanced), use 'desk-remove --purge-history <path/file>'"
}

# --- FUNCTION: fn_purge_history ---
# DANGEROUS: Removes a file from the entire Git history.
fn_purge_history() {
    echo "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è"
    echo "You are about to remove a file from the ENTIRE Git history. This is a dangerous operation,"
    echo "it rewrites history, and requires a 'force push'."
    echo "Using the 'git filter-repo' tool is recommended."
    echo "Are you absolutely sure? (type 'yes' to continue): "
    read -r confirmation
    if [ "$confirmation" != "yes" ]; then
        echo "Operation cancelled."
        exit 1
    fi

    echo "üî• Purging '$2' from the entire history..."
    # This requires git-filter-repo to be installed.
    dotfiles filter-repo --path "$2" --invert-paths --force
    
    echo "üöÄ Force pushing to rewrite history on the remote repository..."
    dotfiles push --force
    echo "‚úÖ History has been rewritten."
}


# ==============================================================================
# MAIN ROUTER (SUBCOMMAND HANDLING)
# ==============================================================================

COMMAND=$1
shift # Remove the first argument so the rest can be passed to the functions

case $COMMAND in
    import)
        fn_import
        ;;
    recovery)
        fn_recovery
        ;;
    backup)
        fn_backup "$@"
        ;;
    log)
        dotfiles log
        ;;
    ignore)
        fn_ignore "$@"
        ;;
    remove)
        if [ "$1" = "--purge-history" ]; then
            shift
            fn_purge_history "$@"
        else
            fn_remove "$@"
        fi
        ;;
    *)
        echo "Invalid command: $COMMAND"
        echo "Usage: desk.sh [import|recovery|backup|ignore|remove|log]"
        exit 1
        ;;
esac
